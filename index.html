<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Streaming JSON-LD</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script class='remove'>
      // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
      var respecConfig = {
        specStatus: "ED",
        shortName: "json-ld-streaming",
        editors: [{
            name:       "Ruben Taelman",
            url:        "https://www.rubensworks.net/",
            company:    "Ghent University â€“ imec",
            companyURL: "http://idlab.ugent.be/",
            w3cid:      "84199",
        }],
        wg:           "JSON-LD Working Group",
        wgURI:        "https://www.w3.org/2018/json-ld-wg/",
        wgPublicList: "public-json-ld-wg",
        maxTocLevel:  4,
        noRecTrack:   "true",
        github:       "https://github.com/w3c/json-ld-streaming/",
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        JSON-LD [[JSON-LD]] offers a JSON-based serialization for Linked Data.
        One of the primary uses of JSON-LD is its ability for RDF exchange across the Web.
        This can be done by first <a class="externalDFN" href="https://www.w3.org/TR/json-ld-api/#serialize-rdf-as-json-ld-algorithm">serializing RDF to JSON-LD</a>,
        after which others can <a class="externalDFN" href="https://www.w3.org/TR/json-ld-api/#deserialize-json-ld-to-rdf-algorithm">deserialize JSON-LD to RDF</a>.
    </p>
    <p>
        Since RDF datasets may contain many triples,
        and JSON-LD documents don't have size limits,
        such documents could become very large.
        For these cases, the ability to serialize and parse JSON-LD in a <em>streaming</em> way offers many advantages,
        as large documents can be parsed with only a limited amount of memory,
        and processed chunks can be emitted as soon as they are processed,
        as opposed to waiting until the whole dataset or document has been processed.
    </p>
    <p>
        The <a class="externalDFN" href="https://www.w3.org/TR/json-ld-api/">recommended processing algorithms</a>
        do not work in a streaming manner, as these first load all required data in memory,
        after which this data can be processed.
        This note discusses the processing of JSON-LD in a streaming way.
        Concretely, a set of guidelines is introduced for efficiently serializing and deserializing JSON-LD in a streaming way.
        These guidelines are encapsulated in a JSON-LD streaming profile,
        so that implementations can detect JSON-LD documents that conform to this profile, and may apply streaming optimizations.
      </p>
    </section>
    <section id="sotd">
      <p>
        This is an unofficial proposal.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
          This document discusses the concerns on serializing and deserializing JSON-LD in a streaming manner.
          This document is primarily intended for the following audiences:
      </p>
      <ul>
          <li>
              Software developers who want to implement the streaming algorithms to serialize or deserialize JSON-LD documents.
          </li>
          <li>
              Web authors and developers who want to publish JSON-LD in a streaming manner.
          </li>
          <li>
              Web authors and developers who want to consume JSON-LD in a streaming manner.
          </li>
      </ul>
      <p>
          To understand the basics in this note you must first be familiar with
          <a data-cite="RFC8259" data-no-xref="">JSON</a>, which is detailed in [[RFC8259]]. You must also understand the
          JSON-LD syntax defined in the <a data-cite="JSON-LD11" data-no-xref="">JSON-LD 1.1 Syntax specification</a> [[JSON-LD11]],
          which is the base syntax used for streaming processing.
          To understand how JSON-LD maps to RDF, it is helpful to be
          familiar with the basic RDF concepts [[RDF11-CONCEPTS]].
      </p>
    </section>
    
    <section id="streaming-document-form">
      <h2>Streaming Document Form</h2>
      <p>
          There are <a class="externalDFN" href="https://www.w3.org/TR/json-ld/#forms-of-json-ld">multiple ways of describing data in JSON-LD</a>,
          each having their own use cases.
          This section introduces a <em>streaming JSON-LD document form</em>,
          which enables JSON-LD documents to be processed in a streaming manner.
      </p>

      <section>
        <h3 id="key-ordering-importance">Importance of Key Ordering</h3>
        <p>
            The order in which key-value pairs occur in JSON-LD nodes conveys no meaning.
            For instance, the following two JSON-LD documents have the same meaning, even though they are syntactically different.
        </p>
        <pre class="example" title="Name, homepage and image come after @id">
          {
            "@context": "http://schema.org/",
            "@id": "https://www.rubensworks.net/#me",
            "name": "Ruben Taelman",
            "url": "https://www.rubensworks.net/",
            "image": "https://www.rubensworks.net/img/ruben.jpg"
          }
        </pre>
        <pre class="example" title="Name, homepage and image come before @id">
          {
            "@context": "http://schema.org/",
            "name": "Ruben Taelman",
            "url": "https://www.rubensworks.net/",
            "image": "https://www.rubensworks.net/img/ruben.jpg",
            "@id": "https://www.rubensworks.net/#me"
          }
        </pre>
        <p>
            In a streaming JSON-LD document, the ordering of (some) keys is important.
            This is because streaming JSON-LD processors may require the presence of some keys before others can be processed,
            and ordering keys in certain ways may lead to better processing performance.
        </p>
        <p>
            In the two snippets before, the first example can be processed more efficiently by a streaming processor.
            Concretely, a streaming JSON-LD deserializer can emit an RDF triple each time a property (<code>"name"</code>, <code>"url"</code>, <code>"image"</code>) has been read, because the <code>"@id"</code> has been defined before.
            This is because the <code>"@id"</code> defines the RDF subject,
            the property key defines the RDF predicate,
            and the property value defines RDF object.
            This ensures that all required information is needed for constructing and emitting and RDF triple each time a property is encountered.
        </p>
        <p>
            For the second example, where the <code>"@id"</code> is only defined at the end,
            a streaming deserializer would have to <em>buffer</em> the properties until the <code>"@id"</code> key is encountered.
            Since the RDF subject of our triples is defined via <code>"@id"</code>,
            the RDF triples can only be emitted after this last key has been read.
        </p>
      </section>
      
      <section>
        <h3 id="key-ordering-required">Required Key Ordering</h3>
        <p>
            In order for a JSON-LD document to be a in a <dfn data-dfn-type="dfn" id="dfn-streaming-document-form">streaming document form</dfn>,
            the keys in each JSON node MUST be ordered according to the following order:
        </p>
        <ol>
            <li><code>@context</code></li>
            <li><code>@type</code> where its value indicates a <a class="externalDFN" href="https://www.w3.org/TR/json-ld/#dfn-type-scoped-context">type-scoped context</a>.</li>
            <li><em>Other properties</em></li>
        </ol>
        <p>
            Each of these keys is optional, and may be omitted.
            Only those that are present must occur in the following order.
        </p>
        <p>
            This order is important because the <code>@context</code> and <code>@type</code> entries
            can change the meaning of all following entries in the node and its children.
            This means that these MUST always be processed before all other entries.
        </p>
        <div class="note" role="note" id="key-ordering-json">
            <p class="">
                Entries in nodes have a defined order when serialized as JSON.
                <a href="https://tools.ietf.org/html/rfc8259#section-4">However, this this order is not always kept by JSON parsing libraries</a>.
                This means that streaming processors MUST make use of JSON parsers that preserve this order to be effective.
            </p>
        </div>
      </section>
      
      <section>
        <h3 id="key-ordering-recommended">Recommended Key Ordering</h3>
        <p>
            In addition to the <a href="#key-ordering-required">required key ordering</a>,
            an <code>@id</code> key SHOULD be present as first of the other properties.
        </p>
        <p>
            By placing <code>@id</code> before other properties in a node,
            streaming deserializers can determine the subject of this node early on,
            and they can immediately emit following properties as RDF triples as soon as they are read.
        </p>
        <p>
            While not recommended, <code>@id</code> can also come after any other properties,
            which requires the streaming deserializer to <em>buffer</em> these properties
            until an <code>@id</code> is read, or the node closes.
        </p>
        <div class="note" role="note" id="key-ordering-recommended-for-who">
            <p class="">
            This recommended key ordering SHOULD be followed by streaming document authors.
            Streaming processors implementations MUST NOT assume that a given streaming document will adhere to this recommendation.
            <br />
            If a processor sees that a document does not adhere to this recommendation, then it MAY produce a warning.
            </p>
        </div>
      </section>
      
      <section>
          <h3 id="streaming-document-examples">Examples</h3>
          <p>
              Hereafter, a couple of JSON-LD document examples are listed that either adhere, adhere with non-recommended order, or not adhere
              to the <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document form</a>.
          </p>
          <section>
              <h3 id="streaming-document-examples-valid">Valid Examples</h3>
              <pre class="example" title="Valid streaming document with @context, @id, and other properties">
                {
                  "@context": {
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image"
                  },
                  "@id": "https://www.rubensworks.net/#me",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
              <pre class="example" title="Valid streaming document with @context, blank @id, and other properties">
                {
                  "@context": {
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image"
                  },
                  "@id": "_:blank_node",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
              <pre class="example" title="Valid streaming document with nested nodes">
                {
                  "@context": {
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image",
                    "knows": "http://schema.org/knows"
                  },
                  "@id": "https://www.rubensworks.net/#me",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg",
                  "knows": {
                    "@id": "https://greggkellogg.net/foaf#me",
                    "name": "Gregg Kellogg",
                  }
                }
              </pre>
              <pre class="example" title="Valid streaming document with nested nodes and embedded context">
                {
                  "@context": {
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image",
                    "knows": "http://schema.org/knows"
                  },
                  "@id": "https://www.rubensworks.net/#me",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg",
                  "knows": {
                    "@context": {
                      "name": "http://xmlns.com/foaf/0.1/name"
                    },
                    "@id": "https://greggkellogg.net/foaf#me",
                    "name": "Gregg Kellogg",
                  }
                }
              </pre>
              <pre class="example" title="Valid streaming document with @context, @type-scoped context, @id, and other properties">
                {
                  "@context": {
                    "Person": {
                      "@id": "http://schema.org/Person",
                      "@context": {
                        "name": "http://schema.org/name",
                        "url": "http://schema.org/url",
                        "image": "http://schema.org/image"
                      }
                    }
                  },
                  "@id": "https://www.rubensworks.net/#me",
                  "@type": "Person",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
              <pre class="example" title="Valid streaming document with @context, plain @type, @id, and other properties">
                {
                  "@context": {
                    "Person": "http://schema.org/Person",
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image"
                  },
                  "@id": "https://www.rubensworks.net/#me",
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg",
                  "@type": "Person" <span class="comment">// Defines no type-scoped context, so may appear anywhere</span>
                }
              </pre>
          </section>
          <section>
              <h3 id="streaming-document-examples-nonrec">Valid, Non-recommended Examples</h3>
              <pre class="example" title="Non-recommended streaming document with @context and without @id">
                {
                  "@context": {
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image"
                  },
                  <span class="comment">// @id is missing, considered a blank node</span>
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
              <pre class="example" title="Valid streaming document without @context and @id">
                {
                  <span class="comment">// @context is not required, but @id is recommended here</span>
                  "http://schema.org/name": "Ruben Taelman",
                  "http://schema.org/url": "https://www.rubensworks.net/",
                  "http://schema.org/image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
          </section>
          <section>
              <h3 id="streaming-document-examples-invalid">Invalid Examples</h3>
              <pre class="example" title="Invalid streaming document where @context comes too late">
                {
                  "@id": "https://www.rubensworks.net/#me",
                  "@context": { <span class="comment">// @context must come before @id</span>
                    "name": "http://schema.org/name",
                    "url": "http://schema.org/url",
                    "image": "http://schema.org/image"
                  },
                  "name": "Ruben Taelman",
                  "url": "https://www.rubensworks.net/",
                  "image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
              <pre class="example" title="Invalid streaming document where @id comes too late">
                {
                  "http://schema.org/name": "Ruben Taelman",
                  "@id": "https://www.rubensworks.net/#me", <span class="comment">// @id must come before name</span>
                  "http://schema.org/url": "https://www.rubensworks.net/",
                  "http://schema.org/image": "https://www.rubensworks.net/img/ruben.jpg"
                }
              </pre>
          </section>
      </section>
      
      <section>
        <h3 id="streaming-profile">Streaming Document Profile</h3>
        <p>
            JSON-LD documents can be signaled or requested in <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document form</a>.
            The profile URI identifying the <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document form</a>
            is <code>http://www.w3.org/ns/json-ld#streaming</code>.
        </p>
        <p>
            The following example illustrates how this profile parameter can be used to request an a streaming document over HTTP.
        </p>
        <div class="example" title="HTTP Request with profile requesting a streaming document">
          <pre data-content-type="http" data-ignore="" aria-busy="false"><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/ordinary-json-document.json</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: example.com
<span class="hljs-attribute">Accept</span>: application/ld+json;<span class="hl-bold">profile=http://www.w3.org/ns/json-ld#streaming</span></code></pre>
          <p>Requests the server to return the requested resource as JSON-LD
            in <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document form</a>.</p>
        </div>
      </section>

    </section>
    
    <section id="streaming-rdf-form">
      <h2>Streaming RDF Form</h2>
      <p>
          This section introduces a <em>streaming RDF dataset form</em>,
          which enables RDF datasets to be processed in a streaming manner
          so that they can efficiently serialized into JSON-LD by a streaming JSON-LD processor.
      </p>
      <section>
        <h3 id="triple-ordering-importance">Importance of Triple Ordering</h3>
        <p>
            The order in which RDF triples occur in an RDF dataset convey no meaning.
            For instance, the following two RDF datasets (serialized in <a href="https://www.w3.org/TR/turtle/">Turtle</a>) have the same meaning,
            even though they have a different order of triples.
        </p>
        <pre class="example" title="A first order of triples">
          @prefix schema: &lt;http://schema.org/&gt; .
          &lt;https://www.rubensworks.net/#me&gt; schema:name "Ruben Taelman" .
          &lt;https://www.rubensworks.net/#me&gt; schema:url &lt;https://www.rubensworks.net/&gt; .
          &lt;https://greggkellogg.net/foaf#me&gt; schema:name "Gregg Kellog" .
          &lt;https://greggkellogg.net/foaf#me&gt; schema:url &lt;https://greggkellogg.net/&gt; .
        </pre>
        <pre class="example" title="A second order of triples">
          @prefix schema: &lt;http://schema.org/&gt; .
          &lt;https://www.rubensworks.net/#me&gt; schema:name "Ruben Taelman" .
          &lt;https://greggkellogg.net/foaf#me&gt; schema:name "Gregg Kellog" .
          &lt;https://www.rubensworks.net/#me&gt; schema:url &lt;https://www.rubensworks.net/&gt; .
          &lt;https://greggkellogg.net/foaf#me&gt; schema:url &lt;https://greggkellogg.net/&gt; .
        </pre>
        <p>
            For streaming JSON-LD processors, the order of RDF triples can however become important.
            Processors that read triples one by one, and convert them to a JSON-LD document in a streaming manner,
            can benefit from having triples in a certain order.
        </p>
        <p>
            For instance, the order from first snippet above can lead to more compact JSON-LD documents than the order from the second snippet
            when handled by a streaming JSON-LD processor.
            This is because the first order groups triples with the same subject,
            which can be exploited during streaming JSON-LD serialization by using the same <code>"@id"</code> key.
            The second order mixes subjects, which means that streaming JSON-LD serialization will have to assign separate <code>"@id"</code> keys
            for each triple, resulting in duplicate <code>"@id"</code> keys.
        </p>
        <p>
            Streaming JSON-LD serializations of both examples can be seen below.
        </p>
        <pre class="example" title="More compact JSON-LD serialization of the first order">
          [
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/name": "Ruben Taelman",
              "http://schema.org/url": { "@id": "https://www.rubensworks.net/" }
            },
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/name": "Gregg Kellog",
              "http://schema.org/url": { "@id": "https://greggkellogg.net/" }
            }
          ]
        </pre>
        <pre class="example" title="Less compact JSON-LD serialization of the second order">
          [
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/name": "Ruben Taelman"
            },
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/name": "Gregg Kellog"
            },
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/url": { "@id": "https://www.rubensworks.net/" }
            },
            {
              "@id": "https://www.rubensworks.net/#me",
              "http://schema.org/url": { "@id": "https://greggkellogg.net/" }
            }
          ]
        </pre>
      </section>
      <section>
        <h3 id="triple-ordering-required">Recommended Triple Ordering</h3>
        <p>
            TODO
        </p>
      </section>
      <section>
        <h3 id="streaming-rdf-profile">Streaming RDF Profile</h3>
        <p>
            TODO
        </p>
      </section>
    </section>
    
    <section id="streaming-processing">
      <h2>Streaming Processing</h2>
      <p>
          Whenever a JSON-LD document is present in <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document form</a>,
          a processor MAY process it in a streaming way.
      </p>
      <p>
          This section describes high-level guidelines for processing JSON-LD in a streaming way.
          Concretely, guidelines are given for <a class="externalDFN" href="https://www.w3.org/TR/json-ld-api/#deserialize-json-ld-to-rdf-algorithm">deserializing JSON-LD to RDF</a>, and <a class="externalDFN" href="https://www.w3.org/TR/json-ld-api/#serialize-rdf-as-json-ld-algorithm">serializing RDF to JSON-LD</a>.
          Further details on processing can be found in <a href="https://www.w3.org/TR/json-ld-api/">the JSON-LD processing algorithms</a>
      </p>
      <section>
        <h3 id="streaming-deserialization">Deserialization</h3>
        <p>
            A streaming deserializer MAY be implemented by considering a JSON-LD document as a stream of incoming characters.
            By reading character-by-character, a deserializer can detect the contained JSON nodes and its key-value pairs.
        </p>
        <p>
            A streaming deserializer MAY assume that the <a href="#key-ordering-required">required key ordering of a <a href="#dfn-streaming-document-form" class="internalDFN" data-link-type="dfn">streaming document</a> is present. If a different order is detected, an error MAY be thrown with error code <code>"invalid streaming key order"</code>.
        </p>
        <p>
            The first expected entry in a node is <code>@context</code>.
            If such an entry is present, all following entries in this node can make us of it, possibly inheriting parts of the context from parent nodes.
            If such an entry is not present, only contexts from parent nodes are considered for this node.
        </p>
        <p>
            If an <code>@type</code> entry is detected,
            it is checked whether or not it defines a type-scoped context according to the current node's context.
            If this defines a type-scoped context, the context for the current node is overridden.
            <br />
            Additionally, the <code>@type</code> must emit <code>rdf:type</code> triples based on the current node's subject and values.
            This subject will possibly only be determined later on, which will require buffering of these incomplete triples.
        </p>
        <p>
            If an <code>@id</code> entry is detected, the RDF subject for the current node is defined for later usage.
            Any other entries that are detected before <code>@id</code> must be buffered until <code>@id</code> is found, or the node closes (which sets the subject to a blank node).
        </p>
        <p>
            For every other property, the default JSON-LD algorithms are followed assuming the current node's subject.
        </p>
      </section>
      <section>
        <h3 id="streaming-serialization">Serialization</h3>
        <p>
            TODO
        </p>
      </section>
    </section>
  </body>
</html>
